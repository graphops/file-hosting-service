
## Feature checklist

- [x] File hasher
  - [x] use sha2-256 as it is more commonly used, faster than sha3-256, both no known hacks (should be easy to switch)
  - [x] Takes a file path and read
  - [x] File manifest to a certain size - currently using a constant of 1MB
  - [X] Hash each chunk as leaves (nodes)
  - [x] Produce a merkle tree
  - [x] construct and write a file_manifest.yaml (root, nodes)
  - [x] Unit tests: same file same hash, different file different hash, big temp file same/modified
  - [x] last chunk lengths, 
- [x] Analyze merkle tree vs hash list for memory usage and verification runtime
- [x] Manifest builder / publisher - CLI
  - [x] Take a file, use File hasher to get the file_manifest, publish file_manifest to IPFS
    - [x] later, take a list of files, use File hasher to hash all files and get root hashes 
  - [x] Construct a manifest with metainfo using YAML builder
    - [x] vectorize
  - [x] May include a status endpoint for the "canonical" publisher, but recognize the endpoint may change later on
  - [x] Publish manifest to IPFS, receive a IPFS hash for the manifest
- [x] IPFS client
  - [x] Connect to an IPFS gateway
  - [x] Post files
  - [x] Cat files
- [x] YAML parser and builder
  - [x] Deserialize and serialize yaml files
- [ ] Manifest server 
  - [x] require operator mnemonic
  - [x] Use a generic path
  - [x] Initialize service; for one Bundle, take (ipfs_hash, local_path)
    - [x] Take a Bundle IPFS hash and get the file using IPFS client
    - [x] Parse yaml file for all the file_manifest hashes using Yaml parser, construct the Bundle object 
      - [x] Take metainfo of file_manifest and search for access by the local_path
      - [x] Verify local file against the chunk hashes
    - [x] vectorize service for multiple bundles
    - [x] Once verified, add to file to the service availability endpoint
  - [x] Route `/` for "Ready to roll!"
  - [x] Route `/operator` for operator info
  - [x] Route `/status` for availability
    - [x] verification for availability
  - [x] Route `/bundles/id/:id` for a Bundle using IPFS hash with range requests
  - [x] Route `/health` for general health
  - [x] Route `/version` for Bundle server version
  - [x] Configure and check free query auth token
  - [ ] (?) Server Certificate
  - [x] Upon receiving a service request (ipfs_hash, range, receipt)
    - [x] start off with request as (ipfs_hash, range)
    - [x] Check if ipfs_hash is available
    - [x] Check if range is valid against the Bundle and the specific file_manifest
    - [ ] TAP: Valid and store receipt
    - [x] Read in the requested chunk
      - [x] Add tests
    - [x] Construct response and respond
      - [ ] determine if streaming is necessary
  - [x] Start with free service and requiring a free query auth token
    - [x] default pricing, allow updates for pricing per byte
  - [x] Runs TAP agent for receipt management
    - [x] Integration testing
- [ ] File Download Client 
  - [x] Take private key/mneomic for wallet connections
  - [x] Request using ipfs_hash
    - [x] take budget for the overall bundle/file
      - [x] construct receipts using budget and chunk sizes
      - [x] add receipt to request
    - [x] add free_token to request
    - [ ] File discovery and matching (Gateway?)
      - [x] Read bundle manifest
      - [x] Ping indexer endpoints data availability
      - [x] Select indexers based on pricing 
      - [ ] Select indexers based on performances
      - [x] Parallel requests
      - [x] Use random endpoints
    - [x] Construct and send requests to indexer endpoints 
      - [x] Parallelize requests
      - [x] Multiple connections (HTTPS over HTTP2)
  - [x] Wait for the responses (For now, assume that the response chunks correspond with the verifiable chunks)
    - [x] Keeps track of the downloaded and missing pieces, 
    - [x] continually requesting missing pieces until the complete file is obtained
    - [x] Upon receiving a response, verify the chunk data in the file_manifest
      - [x] if failed, blacklist the indexer
  - [x] Once all file has been received and verified, terminate

